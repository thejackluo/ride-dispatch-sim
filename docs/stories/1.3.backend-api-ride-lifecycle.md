# Story 1.3: Backend API & Ride Lifecycle

## Status
Draft

## Story
**As a** developer,
**I want** basic API endpoints and simple ride lifecycle,
**so that** the system works for the demo.

## Acceptance Criteria
1. `POST` endpoints for `/drivers`, `/riders`, `/rides`, and `GET /state` are implemented.
2. A `PUT /config` endpoint allows updating the **fairness penalty** weight.
3. The `POST /tick` endpoint is implemented, triggering movement for all drivers.
4. Basic ride lifecycle: `waiting` → `assigned` → `completed` with simple fallbacks.

## Tasks / Subtasks

### Basic API Endpoints
- [ ] Add endpoints to existing `main.py` (AC: 1)
  - [ ] `POST /drivers` - Create driver with x,y coordinates
  - [ ] `POST /riders` - Create rider with x,y coordinates  
  - [ ] `POST /rides` - Create ride with pickup/dropoff coordinates
  - [ ] `GET /state` - Return all entities and current tick

### Configuration Endpoint
- [ ] Add `PUT /config` endpoint (AC: 2)
  - [ ] Simple config dict with fairness_penalty_weight
  - [ ] Update global config variable

### Tick Endpoint
- [ ] Add `POST /tick` endpoint (AC: 3)
  - [ ] Increment tick counter
  - [ ] Move available drivers randomly
  - [ ] Process ride assignments and movements

### Simple Ride Lifecycle
- [ ] Implement basic ride states (AC: 4)
  - [ ] `waiting` → `assigned` → `completed`
  - [ ] Simple rejection: try next driver
  - [ ] Driver movement toward pickup then dropoff

## Dev Notes

### Global State (In main.py)
```python
# Simple global dictionaries
drivers = {}
riders = {}  
rides = {}
current_tick = 0
config = {"fairness_penalty_weight": 1.0}
```

### Basic Endpoints
```python
@app.post("/drivers")
def create_driver(x: int, y: int):
    driver_id = f"driver_{len(drivers)}"
    drivers[driver_id] = {
        "id": driver_id, "x": x, "y": y, 
        "status": "available", "completed_rides": 0
    }
    return drivers[driver_id]

@app.post("/rides") 
def create_ride(rider_id: str, pickup_x: int, pickup_y: int, 
                dropoff_x: int, dropoff_y: int):
    ride_id = f"ride_{len(rides)}"
    rides[ride_id] = {
        "id": ride_id, "rider_id": rider_id,
        "pickup_x": pickup_x, "pickup_y": pickup_y,
        "dropoff_x": dropoff_x, "dropoff_y": dropoff_y,
        "status": "waiting", "assigned_driver_id": None
    }
    # Try to assign immediately
    assign_ride(ride_id)
    return rides[ride_id]

@app.post("/tick")
def advance_tick():
    global current_tick
    current_tick += 1
    # Move available drivers randomly
    # Move assigned drivers toward pickup/dropoff
    # Process ride completions
    return {"tick": current_tick}
```

### Simple Dispatch Logic
```python
def assign_ride(ride_id):
    ride = rides[ride_id]
    available_drivers = [d for d in drivers.values() 
                        if d["status"] == "available"]
    
    if available_drivers:
        # Sort by completed rides (fairness) then distance
        best_driver = min(available_drivers, 
                         key=lambda d: (d["completed_rides"], 
                                       abs(d["x"] - ride["pickup_x"]) + 
                                       abs(d["y"] - ride["pickup_y"])))
        
        # Simple acceptance (always accept for now)
        ride["assigned_driver_id"] = best_driver["id"]
        ride["status"] = "assigned"
        best_driver["status"] = "assigned"
```

### Movement Logic
```python
def move_driver_toward(driver, target_x, target_y):
    if driver["x"] < target_x:
        driver["x"] += 1
    elif driver["x"] > target_x:
        driver["x"] -= 1
    elif driver["y"] < target_y:
        driver["y"] += 1
    elif driver["y"] > target_y:
        driver["y"] -= 1
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-18 | 1.0 | Simplified story creation | Sarah (PO) |
