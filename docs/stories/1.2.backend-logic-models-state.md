# Story 1.2: Backend Logic, Models, & State

## Status
Draft

## Story
**As a** developer,
**I want** to define the core data models, manage the simulation state in-memory, and implement the primary dispatch algorithms,
**so that** the brain of the backend is complete.

## Acceptance Criteria
1. Pydantic models for `Driver`, `Rider`, and `RideRequest` are defined.
2. A state module holds all simulation data in Python dictionaries.
3. The dispatch algorithm finds drivers within a circular **search radius** and prioritizes them in a queue based on the **lowest number of completed rides**.
4. The driver acceptance logic rejects rides if the pickup location is outside their current search radius.
5. A driver's search radius **increases over time** while they are idle.
6. All distance calculations use **Manhattan distance**.
7. `available` drivers move **randomly** one grid unit per tick.

## Tasks / Subtasks

### Data Models Definition
- [ ] Create Pydantic models in `backend/src/models/` (AC: 1)
  - [ ] Create `Driver` model with required attributes
    - [ ] `id: str` - Unique driver identifier
    - [ ] `x: int, y: int` - Current grid position (0-99)
    - [ ] `status: DriverStatus` - Enum: available, assigned, on_trip
    - [ ] `search_radius: int` - Current search radius for accepting rides
    - [ ] `completed_rides: int` - Count of successfully completed rides
    - [ ] `idle_ticks: int` - Number of ticks spent idle (for radius growth)
    - [ ] `current_ride_id: Optional[str]` - ID of assigned/active ride
  - [ ] Create `Rider` model with required attributes
    - [ ] `id: str` - Unique rider identifier
    - [ ] `x: int, y: int` - Current grid position (0-99)
    - [ ] `status: RiderStatus` - Enum: waiting, picked_up, completed
  - [ ] Create `RideRequest` model with required attributes
    - [ ] `id: str` - Unique ride request identifier
    - [ ] `rider_id: str` - Reference to requesting rider
    - [ ] `pickup_x: int, pickup_y: int` - Pickup coordinates
    - [ ] `dropoff_x: int, dropoff_y: int` - Destination coordinates
    - [ ] `status: RideStatus` - Enum: waiting, assigned, pickup, on_trip, completed, failed
    - [ ] `assigned_driver_id: Optional[str]` - Currently assigned driver
    - [ ] `rejected_driver_ids: List[str]` - Drivers who rejected this ride
    - [ ] `created_tick: int` - Tick when ride was requested
    - [ ] `cooldown_until_tick: Optional[int]` - Cooldown period after rejection
- [ ] Create status enums (AC: 1)
  - [ ] `DriverStatus` enum with all required states
  - [ ] `RiderStatus` enum with all required states  
  - [ ] `RideStatus` enum with all required states

### State Management Module
- [ ] Create `backend/src/state.py` module (AC: 2)
  - [ ] Create `SimulationState` class with dictionary storage
    - [ ] `drivers: Dict[str, Driver]` - All drivers in system
    - [ ] `riders: Dict[str, Rider]` - All riders in system
    - [ ] `ride_requests: Dict[str, RideRequest]` - All ride requests
    - [ ] `current_tick: int` - Current simulation tick counter
    - [ ] `config: Dict[str, Any]` - Configuration parameters
  - [ ] Implement state management methods (AC: 2)
    - [ ] `add_driver(driver: Driver)` - Add driver to system
    - [ ] `add_rider(rider: Rider)` - Add rider to system
    - [ ] `add_ride_request(ride: RideRequest)` - Add ride request
    - [ ] `get_available_drivers() -> List[Driver]` - Filter available drivers
    - [ ] `get_waiting_rides() -> List[RideRequest]` - Filter waiting rides
  - [ ] Create global state instance for API access (AC: 2)

### Distance and Geometry Utilities
- [ ] Create `backend/src/utils/geometry.py` (AC: 6)
  - [ ] Implement `manhattan_distance(x1: int, y1: int, x2: int, y2: int) -> int`
  - [ ] Implement `is_within_radius(center_x: int, center_y: int, target_x: int, target_y: int, radius: int) -> bool`
  - [ ] Add comprehensive unit tests for distance calculations
  - [ ] Validate grid boundary constraints (0-99 coordinates)

### Dispatch Algorithm Implementation  
- [ ] Create `backend/src/algorithms/dispatch.py` (AC: 3)
  - [ ] Implement `find_eligible_drivers(ride: RideRequest, drivers: List[Driver]) -> List[Driver]`
    - [ ] Filter drivers by availability status
    - [ ] Filter drivers within search radius of pickup location (AC: 3)
    - [ ] Use Manhattan distance for all calculations (AC: 6)
  - [ ] Implement `prioritize_drivers(eligible_drivers: List[Driver]) -> List[Driver]` (AC: 3)
    - [ ] Sort by lowest number of completed rides first (fairness)
    - [ ] Secondary sort by distance to pickup (efficiency)
    - [ ] Return prioritized queue of drivers
  - [ ] Implement `dispatch_ride(ride_id: str) -> bool` (AC: 3)
    - [ ] Find eligible drivers for the ride
    - [ ] Attempt assignment to highest priority driver
    - [ ] Return success/failure status

### Driver Acceptance Logic
- [ ] Create `backend/src/algorithms/acceptance.py` (AC: 4)
  - [ ] Implement `should_accept_ride(driver: Driver, ride: RideRequest) -> bool` (AC: 4)
    - [ ] Check if pickup location is within driver's current search radius
    - [ ] Use Manhattan distance for radius calculation (AC: 6)
    - [ ] Return acceptance decision
  - [ ] Implement `process_driver_response(driver_id: str, ride_id: str, accepted: bool)`
    - [ ] Update ride status based on acceptance/rejection
    - [ ] Add driver to rejected list if declined
    - [ ] Trigger fallback dispatch if rejected

### Driver Behavior and Movement
- [ ] Create `backend/src/algorithms/movement.py` (AC: 7)
  - [ ] Implement `move_driver_randomly(driver: Driver)` (AC: 7)
    - [ ] Generate random direction (up, down, left, right)
    - [ ] Move exactly one grid unit per tick
    - [ ] Ensure movement stays within grid bounds (0-99)
    - [ ] Only move drivers with `available` status
  - [ ] Implement `update_driver_search_radius(driver: Driver)` (AC: 5)
    - [ ] Increase search radius based on idle time
    - [ ] Reset idle counter when driver becomes busy
    - [ ] Define maximum search radius limits

### Algorithm Integration and Testing
- [ ] Create comprehensive unit tests (AC: 1-7)
  - [ ] Test all Pydantic model validation
  - [ ] Test state management operations
  - [ ] Test dispatch algorithm with various scenarios
  - [ ] Test driver acceptance logic edge cases
  - [ ] Test movement and radius update algorithms
  - [ ] Test Manhattan distance calculations
- [ ] Create integration tests for algorithm coordination
  - [ ] Test complete dispatch-to-acceptance flow
  - [ ] Test rejection fallback mechanisms
  - [ ] Test multi-driver, multi-ride scenarios

## Dev Notes

### Core Algorithm Logic

**Dispatch Priority Algorithm:**
1. Find all available drivers
2. Filter drivers within search radius of pickup (Manhattan distance)
3. Sort by completed_rides ASC (fairness first)
4. Secondary sort by distance to pickup ASC (efficiency)
5. Attempt assignment to first driver in queue

**Driver Acceptance Criteria:**
- Driver must be in `available` status
- Pickup location must be within driver's current search_radius
- Distance calculated using Manhattan distance: `|x1-x2| + |y1-y2|`

**Search Radius Growth:**
- Initial search radius: 5 units
- Increases by 1 unit every 10 idle ticks
- Maximum search radius: 20 units
- Resets to initial when driver accepts a ride

**Movement Rules:**
- Only `available` drivers move randomly
- Movement is exactly 1 grid unit per tick
- Valid moves: up, down, left, right (no diagonal)
- Grid boundaries: 0 ≤ x,y ≤ 99

### State Architecture
```python
# Example state structure
{
    "drivers": {
        "driver_1": {
            "id": "driver_1",
            "x": 45, "y": 23,
            "status": "available",
            "search_radius": 7,
            "completed_rides": 3,
            "idle_ticks": 20,
            "current_ride_id": None
        }
    },
    "ride_requests": {
        "ride_1": {
            "id": "ride_1",
            "rider_id": "rider_1", 
            "pickup_x": 50, "pickup_y": 25,
            "dropoff_x": 75, "dropoff_y": 80,
            "status": "waiting",
            "assigned_driver_id": None,
            "rejected_driver_ids": [],
            "created_tick": 15,
            "cooldown_until_tick": None
        }
    }
}
```

### Testing Standards
- **Unit Tests**: Test each algorithm function independently
- **Integration Tests**: Test algorithm interactions with state
- **Edge Cases**: Test boundary conditions, empty states, invalid inputs
- **Performance**: Ensure algorithms scale with 100+ drivers/rides

### Configuration Parameters
- `INITIAL_SEARCH_RADIUS`: 5 units
- `MAX_SEARCH_RADIUS`: 20 units  
- `RADIUS_GROWTH_INTERVAL`: 10 ticks
- `GRID_SIZE`: 100x100
- `REJECTION_COOLDOWN_TICKS`: 5 ticks

### Error Handling
- Validate all coordinate inputs are within grid bounds
- Handle empty driver/ride lists gracefully
- Log dispatch failures for debugging
- Ensure state consistency after all operations

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-18 | 1.0 | Initial story creation | Sarah (PO) |
